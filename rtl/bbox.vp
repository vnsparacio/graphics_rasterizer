/*
 * Bounding Box Module
 *     
 * Inputs: 
 *   3 x,y,z vertices corresponding to tri 
 *   1 valid bit, indicating triangle is valid data
 * 
 *  Config Inputs:
 *   2 x,y vertices indicating screen dimensions
 *   1 integer representing square root of SS (16MSAA->4)
 *      we will assume config values are held in some
 *      register and are valid given a valid polygon
 * 
 *  Control Input:
 *   1 halt signal indicating that no work should be done 
 * 
 * Outputs:
 *   2 vertices describing a clamped bounding box
 *   1 Valid signal indicating that bounding 
 *           box and triangle value is valid
 *   3 x,y vertices corresponding to tri
 * 
 * Global Signals: 
 *   clk, rst
 * 
 * Function:
 *   Determine a bounding box for the polygon
 *   represented by the vertices.
 * 
 *   Clamp the Bounding Box to the subsample pixel
 *   space
 *   
 *   Clip the Bounding Box to Screen Space
 *
 *   Halt operating but retain values if next stage is busy
 *
 * 
 * Long Description:
 *   This bounding box block accepts a polygon described with three
 *   vertices and determines a set of sample points to test against
 *   the micropolygon.  These sample points correspond to the 
 *   either the pixels in the final image or the pixel fragments 
 *   that compose the pixel if multisample anti-aliasing (MSAA)
 *   is enabled.
 * 
 *   The inputs to the box are clocked with a bank of dflops.  
 * 
 *   After the data is clocked, a bounding box is determined 
 *   for the micropolygon. A bounding box can be determined 
 *   through calculating the maxima and minima for x and y to 
 *   generate a lower left vertice and upper right
 *   vertice.  This data is then clocked.
 * 
 *   The bounding box next needs to be clamped to the fragment grid.
 *   This can be accomplished through rounding the bounding box values
 *   to the fragment grid.  Additionally, any sample points that exist
 *   outside of screen space should be rejected.  So the bounding box
 *   can be clipped to the visible screen space.  This clipping is done
 *   using the screen signal.
 *
 *   The Halt signal is utilized to hold the current polygon bounding box.
 *   This is because one bounding box operation could correspond to
 *   multiple sample test operations later in the pipe.  As these samples
 *   can take a number of cycles to complete, the data held in the bounding
 *   box stage needs to be preserved.  The halt signal is also required for 
 *   when the write device is full/busy.
 * 
 *   The valid signal is utilized to indicate whether or a polygon 
 *   is actual data.  This can be useful if the device being read from,
 *   has no more micropolygons.
 * 
 * 
 * 
 *   Author: John Brunhaver
 *   Created:      Thu 07/23/09
 *   Last Updated: Fri 09/30/10
 *
 *   Copyright 2009 <jbrunhaver@gmail.com>   
 */

/* A Note on Signal Names:
 *
 * Most signals have a suffix of the form _RxxxxN 
 * where R indicates that it is a Raster Block signal
 * xxxx indicates the clock slice that it belongs to
 * N indicates the type of signal that it is.
 *    H indicates logic high, 
 *    L indicates logic low,
 *    U indicates unsigned fixed point, 
 *    S indicates signed fixed point.
 * 
 */

/* ***************************************************************************
 * Change bar:
 * -----------
 * Date           Author    Description
 * Sep 19, 2012   jingpu    ported from John's original code to Genesis
 *                          
 * ***************************************************************************/

/******************************************************************************
 * PARAMETERIZATION
 * ***************************************************************************/
//; # module parameters
//; my $sig_fig    = parameter(Name=>'SigFig',
//;                            Val=>24, Min=>1, Step=>1, 
//;                            Doc=>"Bits in color and position.");
//; my $radix      = parameter(Name=>'Radix',
//;                            Val=>10, Min=>1, Step=>1, 
//;                            Doc=>"Fraction bits in color and position");
//; my $verts      = parameter(Name=>'Vertices',
//;                            Val=>3, Min=>3, Step=>1, 
//;                            Doc=>"Maximum Vertices in micropolygon");
//; my $axis       = parameter(Name=>'Axis',
//;                            Val=>3, Min=>1, Step=>1, 
//;                            Doc=>"Number of axis foreach vertex 3 is (x,y,z).");
//; my $colors     = parameter(Name=>'Colors',
//;                            Val=>3, Min=>1, Step=>1, 
//;                            Doc=>"Number of color channels");
//; my $pipe_depth = parameter(Name=>'PipelineDepth',
//;                            Val=>3, Min=>1, Step=>1, 
//;                            Doc=>"How many pipe stages are in this block");



module `mname()`
  (
   //Input Signals
   input logic signed [`$sig_fig`-1:0] 	poly_R10S[`$verts`-1:0][`$axis`-1:0] , // Sets X,Y Fixed Point Values
   input logic 				unsigned [`$sig_fig`-1:0] color_R10U[`$colors`-1:0] , // Color of Poly
   input logic 				isQuad_R10H , // Is Poly Quad?
   input logic 				validPoly_R10H , // Valid Data for Operation

   //Control Signals
   input logic 				halt_RnnnnL , // Indicates No Work Should Be Done
   input logic signed [`$sig_fig`-1:0] 	screen_RnnnnS[1:0] , // Screen Dimensions
   input logic [3:0] 			subSample_RnnnnU , // SubSample_Interval

   //Global Signals
   input logic 				clk, // Clock 
   input logic 				rst, // Reset

   //Outout Signals
   output logic signed [`$sig_fig`-1:0] poly_R13S[`$verts`-1:0][`$axis`-1:0], // 4 Sets X,Y Fixed Point Values
   output logic 			unsigned [`$sig_fig`-1:0] color_R13U[`$colors`-1:0] , // Color of Poly
   output logic 			isQuad_R13H, // Is Poly Quad?
   output logic signed [`$sig_fig`-1:0] box_R13S[1:0][1:0], // 2 Sets X,Y Fixed Point Values  
   output logic 			validPoly_R13H                  // Valid Data for Operation
   );
   
   
   //Signals In Clocking Order

   //R10 Signals
   logic [1:0][5:0] 			cmp_R10H ;             // Comparison Results
   logic [1:0][1:0][`$verts`-1:0] 	bbox_sel_R10H ;        // Decoded Select for Unclamped Bbox  
   logic signed [`$sig_fig`-1:0] 	box_R10S[1:0][1:0];    // 2 Sets X,Y Fixed Point Values    
   logic signed [`$sig_fig`-1:0] 	rounded_box_R10S[1:0][1:0];  // 2 Sets X,Y Fixed Point Values   
   logic signed [`$sig_fig`-1:0] 	increment_box_R10S[1:0];     // 1 Set X,Y Fixed Point Values 
   logic [1:0][1:0] 			clamp_R10H;                  // signal require clamping
   logic [1:0][1:0] 			invalidate_R10H;             // polygon out of bounds
   logic signed [`$sig_fig`-1:0] 	out_box_R10S[1:0][1:0];      // bounds for output
   logic 				outvalid_R10H;               // output is valid
   //R10 Signals
   
   // output for retiming registers
   logic signed [`$sig_fig`-1:0] 	poly_R13S_retime[`$verts`-1:0][`$axis`-1:0]; // 4 Sets X,Y Fixed Point Values
   logic 				unsigned [`$sig_fig`-1:0] color_R13U_retime[`$colors`-1:0];        // Color of Poly
   logic signed [`$sig_fig`-1:0] 	box_R13S_retime[1:0][1:0];             // 2 Sets X,Y Fixed Point Values  
   logic 				isQuad_R13H_retime;                   // Is Poly Quad?
   logic 				validPoly_R13H_retime ;                 // Valid Data for Operation
   logic				bubbleSmash;

   logic signed [`$sig_fig`-1:0] edges [1:0][1:0];
   logic signed [`$sig_fig`*2:0] xprod;
   logic cull;
   logic culledOutvalid_R10H;
   // output for retiming registers

   //; # if( $verts == 4 ) {
   /* OLD QUAD CODE Used to be here */
   //; # }
   
   /* Note to the bold!!! */
   /* You can actually process more than
    * 3 vertices if you really want.
    * You can even do more than 4.
    * If you are interested in building
    * a paramaterized implementation
    * to evaluate N-vertice draw calls,
    * talk with John B.
    * */

   //; if( $verts == 3 ) {
	always_comb begin
		edges[0][0] = poly_R10S[1][0] - poly_R10S[0][0]; //v2[x]-v1[x]
		edges[0][1] = poly_R10S[1][1] - poly_R10S[0][1]; //v2[y]-v1[y]
		edges[1][0] = poly_R10S[2][0] - poly_R10S[1][0]; //v3[x]-v2[x]
		edges[1][1] = poly_R10S[2][1] - poly_R10S[1][1]; //v3[y]-v2[y]
		
		xprod = edges[0][0] * edges[1][1] - edges[0][1] * edges[1][0];
		cull = (xprod > 0)? 1'b1 : 1'b0;

		bubbleSmash = ~validPoly_R13H || halt_RnnnnL;
	end
   //Note: <= might be faster than < and functionally equivelant here
   always_comb begin
      //Compare X
      cmp_R10H[0][0] =  poly_R10S[0][0] <  poly_R10S[1][0] ;
      cmp_R10H[0][1] =  poly_R10S[0][0] <  poly_R10S[2][0] ;
      cmp_R10H[0][2] =  poly_R10S[1][0] <  poly_R10S[2][0] ;
      cmp_R10H[0][5:3] = 3'b0;
      
      //Compare Y
      cmp_R10H[1][0] =  poly_R10S[0][1] <  poly_R10S[1][1] ;
      cmp_R10H[1][1] =  poly_R10S[0][1] <  poly_R10S[2][1] ;
      cmp_R10H[1][2] =  poly_R10S[1][1] <  poly_R10S[2][1] ;
      cmp_R10H[1][5:3] = 3'b0;
   end 
   
   always_comb begin
      //Decoded Select
      //  sel[n][m][p]
      //  n=0 -> ll n=1 -> ur
      //  m=0 -> x  m=1 -> y
      //  p correspeonds to vertice index
      
      // X
      bbox_sel_R10H[0][0][0] =  cmp_R10H[0][0] &  cmp_R10H[0][1] ;	    
      bbox_sel_R10H[0][0][1] = !cmp_R10H[0][0] &  cmp_R10H[0][2] ; 
      bbox_sel_R10H[0][0][2] = !cmp_R10H[0][1] & !cmp_R10H[0][2] ; 
      bbox_sel_R10H[1][0][0] = !cmp_R10H[0][0] & !cmp_R10H[0][1] ; 
      bbox_sel_R10H[1][0][1] =  cmp_R10H[0][0] & !cmp_R10H[0][2] ; 
      bbox_sel_R10H[1][0][2] =  cmp_R10H[0][1] &  cmp_R10H[0][2] ; 
      
      // Y
      bbox_sel_R10H[0][1][0] =  cmp_R10H[1][0] &  cmp_R10H[1][1]  ; 
      bbox_sel_R10H[0][1][1] = !cmp_R10H[1][0] &  cmp_R10H[1][2]  ; 
      bbox_sel_R10H[0][1][2] = !cmp_R10H[1][1] & !cmp_R10H[1][2]  ; 
      bbox_sel_R10H[1][1][0] = !cmp_R10H[1][0] & !cmp_R10H[1][1]  ; 
      bbox_sel_R10H[1][1][1] =  cmp_R10H[1][0] & !cmp_R10H[1][2]  ; 
      bbox_sel_R10H[1][1][2] =  cmp_R10H[1][1] &  cmp_R10H[1][2]  ; 

      //Check that the Select is OneHot (only one bit in array is 1)
      assert( rst | $onehot( bbox_sel_R10H[0][0] )) 
	else $error("%b \n",bbox_sel_R10H[0][0]) ;
      assert( rst |  $onehot( bbox_sel_R10H[1][0] )) 
	else $error("%b \n",bbox_sel_R10H[1][0]);
      assert( rst |  $onehot( bbox_sel_R10H[0][1] )) 
	else $error("%b \n",bbox_sel_R10H[0][1]) ;
      assert( rst |  $onehot( bbox_sel_R10H[1][1] )) 
	else $error("%b \n",bbox_sel_R10H[1][1]);
      //Check that the Select is OneHot (only one bit in array is 1)
      
      //Perform the Selection
      //  note that unique indicates that 
      //  one and only one select signal will be valid
      //  and that only one case event will occur   
      //
      //  This will synthesize to a simple mux with decoded select
      
      //Upper Right X Select
      unique case( 1'b1 )
	( bbox_sel_R10H[1][0][0] ): box_R10S[1][0] = poly_R10S[0][0] ;
	( bbox_sel_R10H[1][0][1] ): box_R10S[1][0] = poly_R10S[1][0] ;
	( bbox_sel_R10H[1][0][2] ): box_R10S[1][0] = poly_R10S[2][0] ;
      endcase // 
      
      //Lower Left X Select
      unique case( 1'b1 )
	( bbox_sel_R10H[0][0][0] ): box_R10S[0][0] = poly_R10S[0][0] ;
	( bbox_sel_R10H[0][0][1] ): box_R10S[0][0] = poly_R10S[1][0] ;
	( bbox_sel_R10H[0][0][2] ): box_R10S[0][0] = poly_R10S[2][0] ;
      endcase //

      //Upper Right Y Select
      unique case( 1'b1 )
	( bbox_sel_R10H[1][1][0] ): box_R10S[1][1] = poly_R10S[0][1] ;
	( bbox_sel_R10H[1][1][1] ): box_R10S[1][1] = poly_R10S[1][1] ;
	( bbox_sel_R10H[1][1][2] ): box_R10S[1][1] = poly_R10S[2][1] ;
      endcase // 
      
      //Lower Left Y Select
      unique case( 1'b1 )
	( bbox_sel_R10H[0][1][0] ): box_R10S[0][1] = poly_R10S[0][1] ;
	( bbox_sel_R10H[0][1][1] ): box_R10S[0][1] = poly_R10S[1][1] ;
	( bbox_sel_R10H[0][1][2] ): box_R10S[0][1] = poly_R10S[2][1] ;
      endcase //

      //End Selection of Bounding Box    
      
   end // always_comb 
   //; }  

   
   //Round Values to Subsample Interval
   //
   // We will use the floor operation for rounding.
   // To floor a signal, we simply turn all of the bits
   // below a specific `$radix` to 0.
   // The complication here is that there are 4 setting.
   // 1x MSAA eq. to 1 sample per pixel
   // 4x MSAA eq to 4 samples per pixel, a sample is
   // half a pixel on a side
   // 16x MSAA eq to 16 sample per pixel, a sample is
   // a quarter pixel on a side.  
   // 64x MSAA eq to 64 samples per pixel, a sample is
   // an eighth of a pixel on a side.

   // Note: Cleverly converting the MSAA signal
   //       to a mask would allow you to do this operation
   //       as a bitwise and operation.

   // Why is it a floor operation?
   //  TODO -> Explanation of why it is floor
   
   //Round LowerLeft and UpperRight for X and Y
   //; for( my $i = 0 ; $i < 2 ; $i++ ) {
   //; 	for( my $j = 0 ; $j < 2 ; $j++ ) {
   always_comb begin
      
      //Integer Portion of LL Remains the Same 
      rounded_box_R10S[`$i`][`$j`][`$sig_fig`-1:`$radix`] 
     = box_R10S[`$i`][`$j`][`$sig_fig`-1:`$radix`];

      //Fractional Portion LL less than Subsample set to 0
      rounded_box_R10S[`$i`][`$j`][`$radix`-4:0] 
	= `$radix-3`'b0;
      
      //Mux for Correct Roundoff Point 
      assert( $onehot( subSample_RnnnnU )) else $fatal( "onehot\n");
      
      unique case( subSample_RnnnnU )
	(4'b0001): // 64x MSAA
	  rounded_box_R10S[`$i`][`$j`][`$radix`-1:`$radix`-3] 
	       = { box_R10S[`$i`][`$j`][`$radix`-1:`$radix`-3] };  
	(4'b0010): // 16x MSAA
		 rounded_box_R10S[`$i`][`$j`][`$radix`-1:`$radix`-3] 
	  = { box_R10S[`$i`][`$j`][`$radix`-1:`$radix`-2] , 1'b0 };  
	(4'b0100): // 4x MSAA
	    rounded_box_R10S[`$i`][`$j`][`$radix`-1:`$radix`-3] 
	  = { box_R10S[`$i`][`$j`][`$radix`-1] , 2'b0 }; 
	(4'b1000): // 1x MSAA
	    rounded_box_R10S[`$i`][`$j`][`$radix`-1:`$radix`-3] 
	  = { 3'b0 } ;
      endcase // case ( subSample_RnnnnU )
      
      //Assertion Checks at end of Module
      
   end // always_comb
   //;		}
   //; }
   //Round Values to Subsample Interval


   
   //Check if Unclamped Box Requires Clipping or Rejection
   always_comb begin
      //Clamp if LL is down/left of screen origin
      clamp_R10H[0][0] = box_R10S[0][0] < 0 ;
      clamp_R10H[0][1] = box_R10S[0][1] < 0 ;

      //Clamp if UR is up/right of Screen
      clamp_R10H[1][0] = box_R10S[1][0] > screen_RnnnnS[0] ;
      clamp_R10H[1][1] = box_R10S[1][1] > screen_RnnnnS[1] ;

      //Invalid if BBox is up/right of Screen
      invalidate_R10H[0][0] = box_R10S[0][0] > screen_RnnnnS[0] ;
      invalidate_R10H[0][1] = box_R10S[0][1] > screen_RnnnnS[1] ;

      //Invalid if BBox is down/left of Screen
      invalidate_R10H[1][0] = box_R10S[1][0] < 0 ;	    
      invalidate_R10H[1][1] = box_R10S[1][1] < 0 ;	    
   end
   //Check if Unclamped Box Requires Clipping or Rejection

   
   //Select Between Clipped Bounds and Rounded Bounds
   always_comb begin
      out_box_R10S[0][0] = 
			   clamp_R10H[0][0] ? 0 : rounded_box_R10S[0][0] ;
      out_box_R10S[0][1] = 
			   clamp_R10H[0][1] ? 0 : rounded_box_R10S[0][1] ;
      out_box_R10S[1][0] = 
			   clamp_R10H[1][0] ? screen_RnnnnS[0] : rounded_box_R10S[1][0] ;
      out_box_R10S[1][1] = 
			   clamp_R10H[1][1] ? screen_RnnnnS[1] : rounded_box_R10S[1][1];
   end
   //Select Between Screen Bounds and Rounded Bounds
   
   assign  outvalid_R10H = ~( | invalidate_R10H ) & validPoly_R10H;
   assign  culledOutvalid_R10H = outvalid_R10H & ~ cull;

   
   //Flop Clamped Box to R13_retime with retiming registers
   //; my $d_bbx_r1 = generate( 'dff3', "d_bbx_r1", 
   //;                        BitWidth=>$sig_fig,
   //;                        ArraySize1=>$verts,
   //;                        ArraySize2=>$axis,
   //;                        PipelineDepth=>$pipe_depth-1,
   //;                        Retime=>'YES' );
   `$d_bbx_r1->instantiate()` (
			       .in(poly_R10S) , 
			       .clk(clk) , .reset(rst), .en(bubbleSmash),
			       .out(poly_R13S_retime));
   
   //; my $d_bbx_r2 = generate( 'dff2', "d_bbx_r2", 
   //;                        BitWidth=>$sig_fig,
   //;                        ArraySize1=>$colors,
   //;                        PipelineDepth=>$pipe_depth-1,
   //;                        Retime=>'YES' );
   `$d_bbx_r2->instantiate()`(
			      .in(color_R10U) , 
			      .clk(clk) , .reset(rst), .en(bubbleSmash),
			      .out(color_R13U_retime));
   
   //; my $d_bbx_r3 = generate( 'dff3', "d_bbx_r3", 
   //;                        BitWidth=>$sig_fig,
   //;                        ArraySize1=>2,
   //;                        ArraySize2=>2,
   //;                        PipelineDepth=>$pipe_depth-1,
   //;                        Retime=>'YES' );
   `$d_bbx_r3->instantiate()` (
			       .in(out_box_R10S) , 
			       .clk(clk) , .reset(rst), .en(bubbleSmash),
			       .out(box_R13S_retime));
   
   //; my $d_bbx_r4 = generate( 'dff', "d_bbx_r4", 
   //;                        BitWidth=>2,
   //;                        PipelineDepth=>$pipe_depth-1,
   //;                        Retime=>'YES' );
   `$d_bbx_r4->instantiate()`(
			      .in({isQuad_R10H, culledOutvalid_R10H}), //outvalid_R10H}) , 
			      .clk(clk) , .reset(rst), .en(halt_RnnnnL),
			      .out({isQuad_R13H_retime, validPoly_R13H_retime}));
   //Flop Clamped Box to R13_retime with retiming registers
   
   
   
   //Flop R13_retime to R13 with fixed registers
   //; my $d_bbx_f1 = generate( 'dff3', "d_bbx_f1", 
   //;                        BitWidth=>$sig_fig,
   //;                        ArraySize1=>$verts,
   //;                        ArraySize2=>$axis,
   //;                        PipelineDepth=>1,
   //;                        Retime=>'NO' );
   `$d_bbx_f1->instantiate()` (
			       .in(poly_R13S_retime) , 
			       .clk(clk) , .reset(rst), .en(bubbleSmash),
			       .out(poly_R13S));
   
   //; my $d_bbx_f2 = generate( 'dff2', "d_bbx_f2", 
   //;                        BitWidth=>$sig_fig,
   //;                        ArraySize1=>$colors,
   //;                        PipelineDepth=>1,
   //;                        Retime=>'NO' );
   `$d_bbx_f2->instantiate()`(
			      .in(color_R13U_retime) , 
			      .clk(clk) , .reset(rst), .en(bubbleSmash),
			      .out(color_R13U));
   
   //; my $d_bbx_f3 = generate( 'dff3', "d_bbx_f3", 
   //;                        BitWidth=>$sig_fig,
   //;                        ArraySize1=>2,
   //;                        ArraySize2=>2,
   //;                        PipelineDepth=>1,
   //;                        Retime=>'NO' );
   `$d_bbx_f3->instantiate()` (
			       .in(box_R13S_retime) , 
			       .clk(clk) , .reset(rst), .en(bubbleSmash),
			       .out(box_R13S));
   
   //; my $d_bbx_f4 = generate( 'dff', "d_bbx_f4", 
   //;                        BitWidth=>2,
   //;                        PipelineDepth=>1,
   //;                        Retime=>'NO' );
   `$d_bbx_f4->instantiate()`(
			      .in({isQuad_R13H_retime, validPoly_R13H_retime}) , 
			      .clk(clk) , .reset(rst), .en(bubbleSmash),
			      .out({isQuad_R13H, validPoly_R13H}));
   //Flop R13_retime to R13 with fixed registers


   //Error Checking Assertions

   //Define a Less Than Property
   //  
   //  a should be less than b
   property rb_lt( rst, a , b , c );
      @(posedge clk) rst | ((a<=b) | !c);
   endproperty

   //Check that Lower Left of Bounding Box is less than equal Upper Right
   assert property( rb_lt( rst, box_R13S[0][0] , box_R13S[1][0] , validPoly_R13H ));
   assert property( rb_lt( rst, box_R13S[0][1] , box_R13S[1][1] , validPoly_R13H ));
   //Check that Lower Left of Bounding Box is less than equal Upper Right
   
   //Error Checking Assertions

   
endmodule 








